# PET Clone - Open hardware implementation of the Commodore PET
# by Daniel Lehenbauer and contributors.
# 
# https://github.com/DLehenbauer/commodore-pet-clone
#
# To the extent possible under law, I, Daniel Lehenbauer, have waived all
# copyright and related or neighboring rights to this project. This work is
# published from the United States.
#
# @copyright CC0 http://creativecommons.org/publicdomain/zero/1.0/
# @author Daniel Lehenbauer <DLehenbauer@users.noreply.github.com> and contributors

set max_board_delay 5

# Aliases
set clk_16           { pll|altpll_component|pll|clk[0] }
set clk_8p           [get_registers { main:main|timing2:timing2|clk_8_o }]
set clk_8n           [get_registers { main:main|timing2:timing2|clk_8n_o }]
set spi_en           [get_registers { main:main|timing2:timing2|enable[0] }]
set enable_1         [get_registers { main:main|timing2:timing2|enable[1] }]
set enable_2         [get_registers { main:main|timing2:timing2|enable[2] }]
set enable_3         [get_registers { main:main|timing2:timing2|enable[3] }]
set enable_4         [get_registers { main:main|timing2:timing2|enable[4] }]
set enable_5         [get_registers { main:main|timing2:timing2|enable[5] }]
set enable_6         [get_registers { main:main|timing2:timing2|enable[6] }]
set cpu_en           [get_registers { main:main|timing2:timing2|enable[7] }]

set clk_cpu  [get_ports { clk_cpu_o }]
set spi_sclk [get_ports { spi_sclk_i }]

# clk_8p/n are phase-shifted 8 MHz ripple clocks derived from clk_16.  (We use ripple
# clocks because the PLL cannot generate a clock this slow.)
create_generated_clock -name "clk_8p"  -source $clk_16 -edges {  1  3  5 } $clk_8p
create_generated_clock -name "clk_8n"  -source $clk_16 -edges {  4  6  8 } $clk_8n

# clk_cpu is a 1 MHz output clock generated by enabling clk_8p
create_generated_clock -name "clk_cpu" -source $clk_8p -edges { 15 16 31 } $clk_cpu

proc ns_from_mhz { mhz } {
	set result [expr { 1000 / $mhz }]
	return $result
}

set spi_sclk_period_mhz 4
set spi_sclk_period_ns [ns_from_mhz $spi_sclk_period_mhz]

create_clock -name "spi_sclk_v" -period $spi_sclk_period_ns

# Input clock of center-aligned source synchronous interface is equal to source clock +90 degrees
# (See AN433 page 43).
create_clock -name "spi_sclk_i" -period $spi_sclk_period_ns \
    -waveform [list [expr { $spi_sclk_period_ns * 0.25 }] [expr { $spi_sclk_period_ns * 0.75 }]] \
    $spi_sclk

# SPI signals relative to spi_sclk_v
set spi_input_ports [get_ports { spi_cs_ni spi_rx_i }]
set spi_output_ports [get_ports { spi_tx_io }]

set_input_delay -min $max_board_delay -clock spi_sclk_v $spi_input_ports
set_input_delay -max $max_board_delay -clock spi_sclk_v $spi_input_ports

set_output_delay -min $max_board_delay -clock spi_sclk_v $spi_output_ports
set_output_delay -max $max_board_delay -clock spi_sclk_v $spi_output_ports

# Automatically constrain PLL and other generated clocks
derive_pll_clocks -create_base_clocks

# Cyclone II family does not support jitter analysis
# derive_clock_uncertainty

# set_input_delay: Specify data valid window on input ports
#
#  clk  ____/‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
#           |<- min ->|   |
#           |<--- max --->|
#
#  data        prev   >---<    next
#
#  min - (hold)  ns that previous data is held following clock edge
#  max - (setup) ns until next data is valid following clock edge

# set_output_delay:
#
#           |<------------ period ----------->|
#  clk  ____/‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\________________/‾‾‾‾‾
#           |<- min ->|   
#                        |<------- max ------>|
#
#  data       prev    >--<        next
#
#  min - (hold)  ns that previous data is held following clock edge
#  max - (setup) 'priod - ns' until data is valid following clock edge.

# CPU
# https://www.westerndesigncenter.com/wdc/documentation/w65c02s.pdf (pg. 25)
    
# Inputs from CPU governed by address setup/hold (tAH, tADS): A[15:0], MLB, R/W, SYNC, VPB
#
# cpu_clk    ‾‾‾‾\________________/‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\____
#                :                                 :
#                |<- tAH ->|                       |<- tAH ->|
#                |<- tADS --->|
#            ==============>--<==============================>

set bus_addr_ports [get_ports { bus_addr_io[*] bus_rw_nio }]
set cpu_tAH 10
set cpu_tADS 40

set_input_delay -clock clk_cpu -clock_fall -min $cpu_tAH $bus_addr_ports
set_input_delay -clock clk_cpu -clock_fall -max $cpu_tADS $bus_addr_ports

# Inputs from CPU governed by write data delay/hold (tDHW, tMDS): D[7:0]
#
# cpu_clk    ‾‾‾‾\________________/‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\____________
#                :                :                :
#                |<- tDHW ->|     :                |<- tDHW ->|
#                                 |<- tMDS ->|
#            ===============>----------------<================>-

set bus_data_ports [get_ports { bus_data_io[*] }]
set cpu_tDHW 10
set cpu_tMDS 40

set_input_delay -clock clk_cpu -min [expr { ($cpu_tDHW - (1000 / 16)) }] $bus_data_ports
set_input_delay -clock clk_cpu -max $cpu_tMDS $bus_data_ports

# Outputs to CPU governed by read data hold/setup (tDHR, tDSR)
#
#  cpu_clk     ____/‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\________________/‾‾‾‾‾
#                                   :
#                                   |<- tDHR -> |
#                        |<- tDSR ->|
#             -----------<====================>------------

set cpu_tDHR 10
set cpu_tDSR 15
set_output_delay -clock clk_cpu -clock_fall -min $cpu_tDHR $bus_data_ports -add_delay
set_output_delay -clock clk_cpu -clock_fall -max $cpu_tDSR $bus_data_ports -add_delay

# IO
# Data delay to IO chips added by transciever / level-shifters is ~7ns in both directions
# Transition in/out of high-Z is bounded at ~10ns
# https://www.ti.com/lit/ds/symlink/sn74lvc4245a.pdf

set io_tPHL 7
set io_tPZ 10

set io_oe_port [get_ports { io_oe_no }]
set_output_delay -clock { clk_cpu } -min [expr { ($io_tPZ - (1000 / 16)) }] $io_oe_port -add_delay
set_output_delay -clock { clk_cpu } -max $io_tPZ $io_oe_port -add_delay

# PIA/VIA
# https://www.westerndesigncenter.com/wdc/documentation/w65c21.pdf (pg. 8)
# https://www.westerndesigncenter.com/wdc/documentation/w65c22.pdf (pg. 42)

# Outputs to IO governed by address hold/setup (tCA*, tAC*): cs2
#
# cpu_clk    ______________/‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\________________/‾‾‾‾‾
#                          :                :
#                          :                |<- tCA* ->|
#               |<- tAC* ->|
#            ---<======================================>-----------

set io_sel_ports [get_ports { \
    via_cs2_no \
    pia2_cs2_no \
    pia1_cs2_no \
}]

# Use the larger setup/hold times from the VIA.
# Include the delay added by the level shifters.
set io_tAC [expr { 10 + $io_tPZ }]
set io_tCA [expr { 10 + $io_tPZ }]

set_output_delay -clock { clk_cpu } -min [expr { ($io_tAC - (1000 / 16)) }] $io_sel_ports -add_delay
set_output_delay -clock { clk_cpu } -max $io_tAC $io_sel_ports -add_delay

# SRAM
# https://www.alliancememory.com/wp-content/uploads/pdf/AS6C1008feb2007.pdf (pg. 4-6)

# SRAM write:
#
#       clk    _________/‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\___________________/‾‾
#        we    ‾‾‾‾‾‾‾‾‾‾‾‾\________________/‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
#                          :                :
#                |<- tAS ->|<---- tWP  ---->|<-- tWR -->|
#                                 |<- tDW ->|<- tDH ->|
#      data    -------------------<===================>------------
#      addr    --<======================================>----------


set ram_tAS 0       ;# Address setup
set ram_tWP 45      ;# Write pulse
set ram_tWR 0       ;# Write recovery

# Write pulse must begin at least tWP ahead of falling clock edge
set ram_we_port [get_ports { ram_we_no }]
set_output_delay -clock { clk_cpu } -clock_fall -min 0 $ram_we_port -add_delay
set_output_delay -clock { clk_cpu } -clock_fall -max $ram_tWP $ram_we_port -add_delay

# Address must be valid tAS ahead of tWP (or tAS + tWP ahead of falling clock edge.)
set ram_addr_ports [get_ports { bus_addr_io[*] ram_addr_o[*] bus_rw_nio }]
set_output_delay -clock { clk_cpu } -clock_fall -min $ram_tWR $ram_addr_ports -add_delay
set_output_delay -clock { clk_cpu } -clock_fall -max [expr { $ram_tAS + $ram_tWP }] $ram_addr_ports -add_delay

set ram_tDW 25      ;# Data to write time overlap
set ram_tDH  0      ;# Data hold from end of write time

# Data must be valid tDW ahead of falling clock edge and held for tDH afterward
set_output_delay -clock { clk_cpu } -clock_fall -min $ram_tDH $bus_addr_ports -add_delay
set_output_delay -clock { clk_cpu } -clock_fall -max $ram_tDW $bus_addr_ports -add_delay

#ram_ce_no
#ram_oe_no


#cpu_en_o
#cpu_ready_o
#cpu_res_naio
#spi_ready_no